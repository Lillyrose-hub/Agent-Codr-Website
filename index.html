.addColorStop(0.5, `rgba(198, 160, 246, ${0.3 * pulse * this.glowIntensity})`);
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(this.x - this.radius * 4, this.y - this.radius * 4, this.radius * 8, this.radius * 8);
                    
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(183, 189, 248, ${pulse * 0.8})`;
                    ctx.fill();
                }

                connectTo(node) {
                    this.connections.push(node);
                }

                drawConnections() {
                    this.connections.forEach(node => {
                        const gradient = ctx.createLinearGradient(this.x, this.y, node.x, node.y);
                        const pulse = Math.sin(Date.now() * 0.002 + this.pulsePhase) * 0.15 + 0.15;
                        
                        gradient.addColorStop(0, `rgba(139, 213, 202, ${pulse})`);
                        gradient.addColorStop(0.5, `rgba(125, 196, 228, ${pulse * 1.5})`);
                        gradient.addColorStop(1, `rgba(139, 213, 202, ${pulse})`);
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        
                        const cx = (this.x + node.x) / 2 + (Math.random() - 0.5) * 30;
                        const cy = (this.y + node.y) / 2 + (Math.random() - 0.5) * 30;
                        ctx.quadraticCurveTo(cx, cy, node.x, node.y);
                        ctx.stroke();
                    });
                }
            }

            const nodes = [];
            const nodeCount = 25;
            
            for (let i = 0; i < nodeCount; i++) {
                const angle = (i / nodeCount) * Math.PI * 2;
                const radius = 150 + Math.random() * 250;
                const x = canvas.width / 2 + Math.cos(angle) * radius + (Math.random() - 0.5) * 100;
                const y = canvas.height / 2 + Math.sin(angle) * radius + (Math.random() - 0.5) * 100;
                nodes.push(new Node(x, y));
            }

            nodes.forEach((node, i) => {
                for (let j = 0; j < 2; j++) {
                    const targetIndex = (i + Math.floor(Math.random() * 4) + 1) % nodeCount;
                    node.connectTo(nodes[targetIndex]);
                }
            });

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                nodes.forEach(node => node.drawConnections());
                nodes.forEach(node => node.draw());
                requestAnimationFrame(animate);
            }
            animate();

            function createDataStream() {
                const stream = document.createElement('div');
                stream.className = 'data-stream';
                stream.style.left = Math.random() * window.innerWidth + 'px';
                stream.style.animationDelay = Math.random() * 3 + 's';
                stream.style.animationDuration = (3 + Math.random() * 2) + 's';
                const streamsContainer = document.getElementById('dataStreams');
                if (streamsContainer) {
                    streamsContainer.appendChild(stream);
                    setTimeout(() => stream.remove(), 5000);
                }
            }

            setInterval(createDataStream, 800);
        }

        function createParticles() {
            const particlesContainer = document.getElementById('particles');
            const particleCount = 15;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 15 + 's';
                particle.style.animationDuration = (15 + Math.random() * 10) + 's';
                particlesContainer.appendChild(particle);
            }
        }

        function handleHeaderScroll() {
            const header = document.getElementById('header');
            const scrollY = window.scrollY;
            
            if (scrollY > 100) {
                header.classList.add('scrolled');
            } else {
                header.classList.remove('scrolled');
            }
        }

        function initSmoothScrolling() {
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    const target = document.querySelector(this.getAttribute('href'));
                    if (target) {
                        const headerHeight = document.getElementById('header').offsetHeight;
                        const targetPosition = target.offsetTop - headerHeight;
                        
                        window.scrollTo({
                            top: targetPosition,
                            behavior: 'smooth'
                        });
                    }
                });
            });
        }

        function initScrollReveal() {
            const observerOptions = {
                threshold: 0.1,
                rootMargin: '0px 0px -50px 0px'
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach((entry, index) => {
                    if (entry.isIntersecting) {
                        setTimeout(() => {
                            entry.target.classList.add('revealed');
                        }, index * 100);
                    }
                });
            }, observerOptions);

            document.querySelectorAll('.scroll-reveal, .scroll-reveal-left, .scroll-reveal-right').forEach(el => {
                observer.observe(el);
            });
        }

        function animateValue(element, start, end, duration, isDecimal = false) {
            let startTimestamp = null;
            const prefix = element.dataset.prefix || '';
            const suffix = element.dataset.suffix || '';
            
            element.classList.add('counting');
            
            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                
                const easeOutQuart = 1 - Math.pow(1 - progress, 4);
                const currentValue = easeOutQuart * (end - start) + start;
                
                if (isDecimal) {
                    element.textContent = prefix + currentValue.toFixed(1) + suffix;
                } else {
                    element.textContent = prefix + Math.floor(currentValue) + suffix;
                }
                
                if (progress < 1) {
                    window.requestAnimationFrame(step);
                } else {
                    element.classList.remove('counting');
                    element.classList.add('complete');
                    
                    setTimeout(() => {
                        element.classList.remove('complete');
                    }, 5000);
                }
            };
            
            window.requestAnimationFrame(step);
        }

        function initMetricsAnimation() {
            const observerOptions = {
                threshold: 0.5,
                rootMargin: '0px 0px -50px 0px'
            };

            const metricsObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const metric = entry.target;
                        const value = parseFloat(metric.dataset.value);
                        const prefix = metric.dataset.prefix || '';
                        const suffix = metric.dataset.suffix || '';
                        const delay = parseInt(entry.target.closest('.service-card').dataset.delay) || 0;
                        
                        setTimeout(() => {
                            if (prefix === '$') {
                                animateValue(metric, 0, value, 2500, true);
                            } else if (suffix.includes('Hour')) {
                                animateValue(metric, 0, value, 2000, false);
                            } else if (suffix === 'X') {
                                animateValue(metric, 0, value, 2200, false);
                            } else if (suffix === '%') {
                                animateValue(metric, 0, value, 2800, false);
                            }
                        }, delay);
                        
                        metricsObserver.unobserve(metric);
                    }
                });
            }, observerOptions);

            document.querySelectorAll('.result-metric').forEach(metric => {
                metricsObserver.observe(metric);
            });
        }

        function initButtonEffects() {
            const buttons = document.querySelectorAll('.btn, .cta-button, .case-study-link');
            
            buttons.forEach(button => {
                button.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateY(-3px)';
                });
                
                button.addEventListener('mouseleave', function() {
                    this.style.transform = 'translateY(0)';
                });
            });
        }

        function initParallaxEffect() {
            window.addEventListener('scroll', () => {
                const scrolled = window.pageYOffset;
                const heroSection = document.querySelector('.hero');
                if (heroSection) {
                    const rate = scrolled * -0.5;
                    heroSection.style.transform = `translateY(${rate}px)`;
                }
            });
        }

        let ticking = false;
        function requestTick() {
            if (!ticking) {
                requestAnimationFrame(() => {
                    handleHeaderScroll();
                    ticking = false;
                });
                ticking = true;
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            initNeuralNetwork();
            createParticles();
            initSmoothScrolling();
            initScrollReveal();
            initMetricsAnimation();
            initButtonEffects();
            initParallaxEffect();

            window.addEventListener('scroll', requestTick);

            setTimeout(() => {
                document.querySelectorAll('.fade-in, .fade-in-left, .fade-in-right').forEach((el, index) => {
                    setTimeout(() => {
                        el.style.opacity = '1';
                        el.style.transform = 'translateY(0) translateX(0)';
                    }, index * 150);
                });
            }, 300);
        });
    </script>
